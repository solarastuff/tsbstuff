local Library = loadstring(Game:HttpGet("https://raw.githubusercontent.com/bloodball/-back-ups-for-libs/main/wizard"))()
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local UIS = game:GetService("UserInputService")
local lp = Players.LocalPlayer
local camera = workspace.CurrentCamera

local Window = Library:NewWindow("tsbstuff")
local Tab = Window:NewSection("Visuals & Physics")

-- Speed Mod
local ModdingSpeed = false
local HowFast = 0

Tab:CreateToggle("Mod Speed", function(value)
	ModdingSpeed = value
	if value then
		task.spawn(function()
			while ModdingSpeed do
				local char = lp.Character
				local hum = char and char:FindFirstChildWhichIsA("Humanoid")
				if char and hum and hum.MoveDirection.Magnitude > 0 then
					local delta = RunService.Heartbeat:Wait()
					char:TranslateBy(hum.MoveDirection * delta * HowFast)
				else
					RunService.Heartbeat:Wait()
				end
			end
		end)
	end
end)

Tab:CreateTextbox("0", function(text)
	HowFast = tonumber(text) or 0
end)

-- FOV Mod
local ModFOV = false
local FOVAmount = 70

Tab:CreateToggle("Mod FOV", function(value)
	ModFOV = value
	if value then
		task.spawn(function()
			while ModFOV do
				camera.FieldOfView = FOVAmount
				task.wait(0.1)
			end
			camera.FieldOfView = 70
		end)
	else
		camera.FieldOfView = 70
	end
end)

Tab:CreateTextbox("70", function(text)
	FOVAmount = tonumber(text) or 70
	if ModFOV then
		camera.FieldOfView = FOVAmount
	end
end)

-- Gravity Mod
local ModGravity = false
local GravityAmount = 196.2

Tab:CreateToggle("Mod Gravity", function(value)
	ModGravity = value
	if value then
		task.spawn(function()
			while ModGravity do
				workspace.Gravity = GravityAmount
				task.wait(0.1)
			end
			workspace.Gravity = 196.2
		end)
	else
		workspace.Gravity = 196.2
	end
end)

Tab:CreateTextbox("196.2", function(text)
	GravityAmount = tonumber(text) or 196.2
	if ModGravity then
		workspace.Gravity = GravityAmount
	end
end)



local Tab = Window:NewSection("Kombat")


-- Auto Twisted Tech
Tab:CreateToggle("auto twisted", function(value)
	local MOVE_BACKWARD_WAIT = 1.37
	local DASH_WAIT = 0.01
	local MOVE_STUDS = 3
	local startButton

	local function fireServer(args)
		lp.Character.Communicate:FireServer(unpack(args))
	end

	local function getNil(name, class)
		for _, v in ipairs(getnilinstances()) do
			if v.Name == name and v:IsA(class) then
				return v
			end
		end
	end

	local function autoKyotoSequence()
		local args1 = { [1] = { ["Mobile"] = true, ["Goal"] = "LeftClick" } }
		fireServer(args1)
		task.wait(MOVE_BACKWARD_WAIT)
		local args2 = { [1] = { ["Goal"] = "LeftClickRelease", ["Mobile"] = true } }
		fireServer(args2)
		local root = lp.Character.HumanoidRootPart
		lp.Character.Humanoid:MoveTo(root.Position - (root.CFrame.LookVector * MOVE_STUDS))
		lp.Character.Humanoid.MoveToFinished:Wait()
		task.wait(DASH_WAIT)
		local args3 = { [1] = { ["Dash"] = Enum.KeyCode.W, ["Key"] = Enum.KeyCode.Q, ["Goal"] = "KeyPress" } }
		fireServer(args3)
		local bv = getNil("moveme", "BodyVelocity")
		if bv then
			local args4 = { [1] = { ["Goal"] = "delete bv", ["BV"] = bv } }
			fireServer(args4)
		end
	end

	if value then
		if UIS.TouchEnabled and not UIS.KeyboardEnabled then
			local gui = Instance.new("ScreenGui", lp:WaitForChild("PlayerGui"))
			gui.Name = "AutoTwistedTechMobile"
			local twistedButton = Instance.new("TextButton", gui)
twistedButton.Position = UDim2.new(0.5, -60, 0.6, 0)
twistedButton.Size = UDim2.new(0, 120, 0, 45)
twistedButton.Text = "Twisted"
twistedButton.TextScaled = true
twistedButton.Font = Enum.Font.GothamBold
twistedButton.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
twistedButton.TextColor3 = Color3.fromRGB(255, 215, 0) -- gold text
twistedButton.BorderSizePixel = 0
twistedButton.AutoButtonColor = false
twistedButton.ZIndex = 2

-- Rounded corners, slightly tighter
local corner = Instance.new("UICorner", twistedButton)
corner.CornerRadius = UDim.new(0, 8)

-- Glow/shadow
local shadow = Instance.new("Frame", twistedButton)
shadow.Size = UDim2.new(1, 0, 1, 0)
shadow.Position = UDim2.new(0, 3, 0, 3)
shadow.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
shadow.BorderSizePixel = 0
shadow.BackgroundTransparency = 0.6
shadow.ZIndex = 1

local shadowCorner = Instance.new("UICorner", shadow)
shadowCorner.CornerRadius = UDim.new(0, 8)

-- Hover effect (smooth, stylish)
twistedButton.MouseEnter:Connect(function()
	twistedButton.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
end)

twistedButton.MouseLeave:Connect(function()
	twistedButton.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
end)
			startButton.MouseButton1Click:Connect(autoKyotoSequence)
		elseif UIS.KeyboardEnabled then
			UIS.InputBegan:Connect(function(input, gameProcessed)
				if gameProcessed then return end
				if input.KeyCode == Enum.KeyCode.T then
					autoKyotoSequence()
				end
			end)
		end
	else
		local gui = lp:FindFirstChild("PlayerGui"):FindFirstChild("AutoTwistedTechMobile")
		if gui then gui:Destroy() end
	end
end)



--===[ Settings and Script Initialization ]===--

    local players = game:GetService("Players")
local plr = players.LocalPlayer
local cd = false

local Settings = {
    Autoparry = { Toggle = false, Range = 11, Delay = 0, Fov = 360, Facing = false, Dodgerange = 3, Aimhelper = false },
    ESP = { Toggle = false, Config = {} },
    Tpaura = { Toggle = false },
}

local anims = {
    ["rbxassetid://10469493270"] = { [1] = 0, [2] = 0.30 },
    ["rbxassetid://10469630950"] = { [1] = 0, [2] = 0.30 },
    ["rbxassetid://10469639222"] = { [1] = 0, [2] = 0.30 },
    ["rbxassetid://10469643643"] = { [1] = 0, [2] = 0.30 },
    ["rbxassetid://13532562418"] = { [1] = 0, [2] = 0.30 },
    ["rbxassetid://13532600125"] = { [1] = 0, [2] = 0.30 },
    ["rbxassetid://13532604085"] = { [1] = 0, [2] = 0.30 },
    ["rbxassetid://13294471966"] = { [1] = 0, [2] = 0.30 },
    ["rbxassetid://13491635433"] = { [1] = 0, [2] = 0.30 },
    ["rbxassetid://13296577783"] = { [1] = 0, [2] = 0.30 },
    ["rbxassetid://13295919399"] = { [1] = 0, [2] = 0.30 },
    ["rbxassetid://13295936866"] = { [1] = 0, [2] = 0.30 },
    ["rbxassetid://13370310513"] = { [1] = 0, [2] = 0.30 },
    ["rbxassetid://13390230973"] = { [1] = 0, [2] = 0.30 },
    ["rbxassetid://13378751717"] = { [1] = 0, [2] = 0.30 },
}

local dodges = {
    ["rbxassetid://10479335397"] = { [1] = 0, [2] = 0.50 },
    ["rbxassetid://13380255751"] = { [1] = 0, [2] = 0.50 }
}

local barrages = {
    ["rbxassetid://10466974800"] = { [1] = 0.20, [2] = 1.80 },
    ["rbxassetid://12534735382"] = { [1] = 0.20, [2] = 1.80 }
}

local abilities = {
    ["rbxassetid://10468665991"] = { [1] = 0.15, [2] = 0.60 },
    ["rbxassetid://13376869471"] = { [1] = 0.05, [2] = 1 },
    ["rbxassetid://13376962659"] = { [1] = 0, [2] = 2 },
    ["rbxassetid://12296882427"] = { [1] = 0.05, [2] = 1 }, --sonic
    ["rbxassetid://13309500827"] = { [1] = 0.05, [2] = 1 }, --sonic
    ["rbxassetid://13365849295"] = { [1] = 0, [2] = 1 }, --sonic
    ["rbxassetid://13377153603"] = { [1] = 0, [2] = 1 }, --soni
    ["rbxassetid://12509505723"] = { [1] = 0.09, [2] = 2 }, -- dash for cyborg lmao
}

--===[ Function Definitions ]===--

local closestplr, anim, plrDirection, unit, value, dodge

function closest()
    closestplr = {}
    for i, v in next, players:GetChildren() do
        if v.Character and plr.Character:WaitForChild("HumanoidRootPart", 1) and v ~= plr and v.Character ~= plr.Character and v.Character:FindFirstChild("HumanoidRootPart")
            and (v.Character.HumanoidRootPart.Position - plr.Character.HumanoidRootPart.Position).Magnitude < Settings.Autoparry.Range
        then
            table.insert(closestplr, v)
        end
    end
    return closestplr
end

function attackchecker()
    for i, Anim in next, plr.Character.Humanoid.Animator:GetPlayingAnimationTracks() do
        z = anims[Anim.Animation.AnimationId]
        q = dodges[Anim.Animation.AnimationId]
        j = abilities[Anim.Animation.AnimationId]
        k = barrages[Anim.Animation.AnimationId]
        if z or q or j or k then
            return true
        else
            return false
        end
    end
end

function isfacing(object)
    if Settings.Autoparry.Toggle then
        if Settings.Autoparry.Facing then
            plrDirection = plr.Character.Head.CFrame.LookVector
            unit = (object.Head.CFrame.p - plr.Character.Head.CFrame.p).Unit
            value = math.pow((plrDirection - unit).Magnitude / 2, 2)
            if value >= Settings.Autoparry.Fov / 360 then
                return false
            else
                return true
            end
        else
            return true
        end
    end
end

function allowed(enemy)
    if not plr.Character:FindFirstChild("M1ing") and not attackchecker() and isfacing(enemy) then
        return true
    end
end

local durations = {
    ["anim"] = 0.3,
    ["dodge"] = 0.9,
    ["barrage"] = 0.9,
    ["ability"] = 0.6,
}

function def(action)
    if cd then
        return
    end
    task.wait(Settings.Autoparry.Delay)
    print("parry attempt".."|"..action)
    cd = true
    plr.Character.Communicate:FireServer({["Goal"] = "KeyPress", ["Key"] = Enum.KeyCode.F})
    task.wait(durations[action])
    plr.Character.Communicate:FireServer({["Goal"] = "KeyRelease",["Key"] = Enum.KeyCode.F})
    cd = false
end

function barragechecker(enemy)
    if enemy:FindFirstChild("BarrageBind") then
        return true
    else
        return false
    end
end

function lookat(enemy)
    if Settings.Autoparry.Aimhelper then
        plr.Character.HumanoidRootPart.CFrame = CFrame.lookAt(plr.Character.HumanoidRootPart.Position, enemy.HumanoidRootPart.Position)
    end
end

function parry()
    for i, c in closest() do
        if c and plr.Character:WaitForChild("HumanoidRootPart", 2) and c.Character and c.Character:FindFirstChild("Humanoid") and c.Character.Humanoid:FindFirstChild("Animator")
        then
            for i, v in next, c.Character.Humanoid.Animator:GetPlayingAnimationTracks() do
                anim = anims[v.Animation.AnimationId]
                dodge = dodges[v.Animation.AnimationId]
                ability = abilities[v.Animation.AnimationId]
                barrage = barrages[v.Animation.AnimationId]
                if allowed(c.Character) and anim and v.TimePosition >= anim[1] and v.TimePosition <= anim[2] then
                    task.spawn(function()
                        def("anim")
                        lookat(c.Character)
                    end)
                elseif allowed(c.Character) and dodge and v.TimePosition > dodge[1] and v.TimePosition < dodge[2] then
                    task.spawn(function()
                        def("dodge")
                        lookat(c.Character)
                    end)
                elseif allowed(c.Character) and barrage and v.TimePosition > barrage[1] and v.TimePosition < barrage[2] then
                    task.spawn(function()
                        def("barrage")
                        lookat(c.Character)
                    end)
                elseif allowed(c.Character) and ability and v.TimePosition > ability[1] and v.TimePosition < ability[2] then
                    task.spawn(function()
                        def("ability")
                        lookat(c.Character)
                    end)
                end
            end
        end
    end
end

task.spawn(function()
    game:GetService("RunService").RenderStepped:Connect(function()
        if Settings.Autoparry.Toggle then
            parry()
        end
    end)
end)






Tab:CreateToggle("Auto Block", function(value)


Settings.Autoparry.Toggle = value

end)


local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local localPlayer = Players.LocalPlayer
local liveFolder = workspace:WaitForChild("Live")

-- SETTINGS
local CHECK_INTERVAL = 0.1
local TELEPORT_DISTANCE = 20

local currentWeldedPart = nil
local touchConnection = nil
local renderConnection = nil

local function getNearestPlayer()
	local closestPlayer = nil
	local shortestDistance = math.huge
	local myCharacter = liveFolder:FindFirstChild(localPlayer.Name)
	if not myCharacter or not myCharacter:FindFirstChild("HumanoidRootPart") then return nil end

	for _, character in pairs(liveFolder:GetChildren()) do
		if character:IsA("Model") and character ~= myCharacter and character:FindFirstChild("HumanoidRootPart") then
			local dist = (myCharacter.HumanoidRootPart.Position - character.HumanoidRootPart.Position).Magnitude
			if dist < shortestDistance then
				shortestDistance = dist
				closestPlayer = character
			end
		end
	end
	return closestPlayer
end

local function teleportAwayFromPart(part)
	local myCharacter = liveFolder:FindFirstChild(localPlayer.Name)
	if not myCharacter or not myCharacter:FindFirstChild("HumanoidRootPart") then return end

	local hrp = myCharacter.HumanoidRootPart
	local direction = (hrp.Position - part.Position).Unit
	local newPos = part.Position + direction * TELEPORT_DISTANCE
	hrp.CFrame = CFrame.new(newPos, newPos + hrp.CFrame.LookVector)
end

local function setupTouchListener(part)
	if part == nil then return end

	local connection
	connection = part.Touched:Connect(function(hit)
		local myCharacter = liveFolder:FindFirstChild(localPlayer.Name)
		if myCharacter and hit:IsDescendantOf(myCharacter) then
			teleportAwayFromPart(part)
		end
	end)

	return connection
end

local function StartSystem()
	if renderConnection then return end -- Already running

	renderConnection = RunService.RenderStepped:Connect(function()
		local targetChar = getNearestPlayer()
		if not targetChar then
			if currentWeldedPart then
				currentWeldedPart:Destroy()
				currentWeldedPart = nil
			end
			if touchConnection then
				touchConnection:Disconnect()
				touchConnection = nil
			end
			return
		end

		local m1ing = targetChar:FindFirstChild("M1ing")
		if m1ing and not currentWeldedPart then
			local part = Instance.new("Part")
			part.Size = Vector3.new(15, 20, 10)
			part.Shape = Enum.PartType.Block
			part.Anchored = false
			part.CanCollide = false
			part.Transparency = 0.5
			part.BrickColor = BrickColor.new("Bright red")
			part.Name = "M1Hitbox"

			local arm = targetChar:FindFirstChild("Right Arm") or targetChar:FindFirstChild("RightHand")
			if arm then
				part.CFrame = arm.CFrame
				part.Parent = targetChar

				local weld = Instance.new("WeldConstraint")
				weld.Part0 = part
				weld.Part1 = arm
				weld.Parent = part

				currentWeldedPart = part
				touchConnection = setupTouchListener(part)
			else
				part:Destroy()
			end
		elseif not m1ing and currentWeldedPart then
			currentWeldedPart:Destroy()
			currentWeldedPart = nil
			if touchConnection then
				touchConnection:Disconnect()
				touchConnection = nil
			end
		end
	end)
end

local function StopSystem()
	if renderConnection then
		renderConnection:Disconnect()
		renderConnection = nil
	end
	if currentWeldedPart then
		currentWeldedPart:Destroy()
		currentWeldedPart = nil
	end
	if touchConnection then
		touchConnection:Disconnect()
		touchConnection = nil
	end
end

Tab:CreateToggle("auto dodge M1's", function(value)
if value then
StartSystem()
else
StopSystem()

end
end)




